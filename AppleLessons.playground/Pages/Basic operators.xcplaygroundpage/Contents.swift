//: [Previous](@previous)

import Foundation

// MARK: Basic operators
// Оператор присваивания (=) не возвращает значения, что позволяет избежать путаницы с оператором проверки на равенство (==). Арифмитические операторы (+,-,*,/,%) могут обнаруживать и предотвращать переполнение типа, чтобы числовой переменной нельзя было присвоить слишком большое или слишком маленькое значение. Контроль переполнения типа в Swift включается специальными операторами.
// Swift позволяет делить с остатком (%) числа с плавающей точкой

// MARK: Терминология
// Операторы делятся на унарные, бинарные и тернарные:
// Унарные операторы применяются к одной величине (например, -а). Унарные префиксные операторы ставятся непосредственно перед величиной (например, !b), а унарные постфиксные сразу за ней (например, с!)
// Бинарные операторы применяются к двум величинам (например 2 + 3) и являются инфиксными, так как ставятся между этими величинами
// Тернарные операторы применяются к трем величинам. Есть только один тернарный оператор - тернарный условный оператор (a ? b : c)

// Величины к которыс применяются операторы, называются операндами. В выражении 1 + 2 символ + является бинарным оператором, а его операндами служат 1 и 2

// MARK: Оператор присваивания
 // Оператор присваивания (a = b) инициализирует или изменяет значение переменной a на значение b:
let b = 10
var a = 5
a = b

let (x, y) = (1, 2)

// Оператор присваивания не может возвращать значение. Следующее выражение недопустимо:
/*
if x = y {
    // это неверно, так как x = y не возвращает никакого значения
}
*/

// MARK: Арифметические операторы
// Четыре стандартных арифметических оператора для всех числовых типов:
// сложение +
// вычитание -
// деление /
// умножение *

10.0 / 2.5

// MARK: Оператор целочисленного деления
// Оператор целочисленного деления (a % b) определяет, какое количсетво b помещается внутри a, и возвращает остаток деления a на b
9 % 4

// a = (b * множитель) + остаток
// где множитель показывает, сколько раз целыx b содержится в a

// 9 = (4 * 2) + 1
// Точно так же расчитывается остаток когда a отрицательно:
-9 % 4
// -9 = (-4 * 2) + -1

// Если b отрицательно, его знак отбрасывается. Это означает, что выражения a % b и a % -b всегда будут давать одинаковый результат

//  MARK: Оператор унарного минуса
// Для изменения знака числового значения служит префиксный минус -
let three = 3
let minusThree = -three
let plusThree = -minusThree

// MARK: Оператор унарного плюса
// Оператор унарного плюса просто возвращает значение без каких либо изменений
let minusSix = -6
let alsoMinusSix = +minusSix

// MARK: Составные операторы присваивания
// Составные операторы присваивания, совмещают простое присваивание (=) с другой операцией
var u = 1
u += 2
// Составные операторы присваивания не возвращают значение

// MARK: Операторы сравнения
// равно (a == b)
// не равно (a != b)
// больше (a > b)
// меньше (a < b)
// больше или равно (a >= b)
// меньше или равно (a <= b)

// Операторы проверки на идентичность - определяют ссылаются ли два указателся на один и тот же экземпляр класса (===, !==)

// Стандартная библиотека Swift включает в себя операторы сравнения кортежей, которые имеют менее семи значений. Если нужны операторы которые позволяют сравнивать кортежи более, чем шестью элементами, то нужно реализовывать их самостоятельно

(true, "as") == (false, "asf")

// MARK: Тернарный условный оператор
// Тернарный оператор - это короткая удобная конструкция для выбора между двумя выражениями
let contentHeight = 40
let hasHeader = true
var rowHeight = 0
// Тернарный оператор явлется краткой записью кода
if hasHeader {
    rowHeight = 50
} else {
    rowHeight = 20
}
// Тернарный
rowHeight = hasHeader ? 100 : 1

// MARK: Оператор объединения по nil

// Оператор объединения по nil (a ?? b) извлекает опционал a, если он содержит значение, или возвращает значение по умолчанию b, если а равно nil. Выражение a может быть только опционалом. Выражение b должно быть такого же типа, что и значение внутри a.

// Оператор объединения по nil является краткой записью кода:
//a != nil ? a! : b

// (a ?? b)
// Если a не равно nil, выражение b не анализируется. Такой подход называется краткой прверкой условия (short-circuit evaluation)

let defaultColorName = "red"
var userDefinedColorName: String?

var colorNameToUse = userDefinedColorName ?? defaultColorName
userDefinedColorName = "green"
colorNameToUse = userDefinedColorName ?? defaultColorName

// MARK: Операторы диапазона
// В языке Swift есть два оператора диапазона, которые в короткой форме задают диапазон значений

// MARK: Оператор замкнутого диапазона
// Оператор замкнутого диапазона (a...b) задаает диапазон значения от a до b, включая сами a и b. При этом значение a не должно превышать значение b
// Этот оператор удобно применять при последовательном переборе значений из некоторого диапазона

for index in 1...5 {
    print("\(index) умножить на 5 будет \(index * 5)")
}

// MARK: Оператор полузамкнутого диапазона
// Оператор полузамкнутого диапазона (a..<b) задает диапазон значений от a до b, исключая значение b. Такой диапазон называется полузамкнутым, потому что он включает первое значение, но исключает последнее. Если значение a будет равно b, то итоговый диапазон будет пустым

// Операторы полузамкнутого диапазона особенно удобны при работе с массивами и другими последовательностями, пронумерованными с нуля, когда нужно перебрать элементы от первого до последнего:
let names = ["Anna", "Alex", "Brian", "Jack"]

for i in 0..<names.count {
    print(names[i])
}
print("")

// MARK: Односторонние диапазоны
// Односторонние диапазон - диапазон, который продолжается насколько возможно, но только в одну сторону, напрмер диапазон, который включает все элементы массива начиная со второго индекса и до последнего

// Одностороння форма замкнутого диапазона:
for name in names[2...] {
    print(name)
}
print("")

for name in names[...2] {
    print(name)
}
print("")

// Односторонняя форма полузамкнутого диапазона:
for name in names[..<2] {
    print(name)
}

let range = ...5
range.contains(1)
range.contains(-100)
range.contains(7)

// MARK:  Логические операторы
// Язык Swift поддерживает три стандартных логических оператора:
// логическое НЕ (!а)
// логическое И (a && b)
// логические ИЛИ (a || b)

// MARK: Оператор логического НЕ
// Оператор логического НЕ (!а) инвертирует булево значение

let allowedEntry = false
if !allowedEntry {
    print("access denied")
}
allowedEntry

// MARK: Оператор логического И
// Оператор логического И (a && b) дает на выходе true тогда и только тогда, когда оба его операнда true
// Если первое значение равно false, второе и последующие даже не будут анализироваться (краткая проверка условия Short-circuit evaluation)

let enteredDoorCode = true
let passedRetinaScan = false
if enteredDoorCode && passedRetinaScan {
    print("welcome")
} else {
    print("access denied")
}

// MARK: Оператор логического ИЛИ
// Оператор логического ИЛИ (a || b) является инфиксным. Возвращает true, если хотя бы один из операндов true
// Если левая часть выражения будет true, правая часть не будет анализироваться (краткая проверка условия Short-circuit evaluation)

let hasDoorKey = false
let knowsOverridePassword = true
if hasDoorKey || knowsOverridePassword {
    print("welcome")
} else {
    print("access denied")
}

// MARK: Комбинирование логических операторов
if enteredDoorCode && passedRetinaScan || hasDoorKey || knowsOverridePassword {
    print("welcome")
} else {
    print("access denied")
}
// Логические операторы И и ИЛИ являются лево-ассоциированными, что означает, что составные выражения с логическими операторами оценивают в первую очередь выражения слева направо

// MARK: Явное указание круглых скобок

if (enteredDoorCode && passedRetinaScan) || hasDoorKey || knowsOverridePassword {
    print("welcome")
} else {
    print("access denied")
}
// Желательно ставить круглые скобки везде, где они облегчают понимание



//: [Next](@next)
