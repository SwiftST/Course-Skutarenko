import UIKit

// MARK: Константы и переменные
// Константы и переменные должны быть объявлены перед тем как вы будете их использовать

var x = 0.0, y = 1.1, z = 0.1

// если значение в вешем коде не будет меняться всегда объявляйте его как константу

// MARK: Aннотация типов

var welcomeMessage: String
welcomeMessage = "Hi"

var red, blue, green: Double 

// MARK: Названия констант и переменных
// Если нужно объявить константу или переменную тем же именем что и зарезервированное слово в Swift то можно воспользоваться (`) обратными ковычками

var `func` = 1223
`func` += 23

// MARK: Точка с запятой (;)
// Swift не требует писать точку с запятой после каждоый строки кода.
// Однако они нужны если необходимо написать несколько отдельных выражений на строке

let cat = "?"; print(cat)

// MARK: Int, UInt
// Int - знаковый тип данный
// UInt - беззнаковый тип данных, который может хранить только положительные целочисленные значеия или ноль
let minUInt8 = UInt8.min
let maxUInt8 = UInt8.max

// MARK: Числа с плавающей точкой

// Double - имеет точность минимум 15 десятичных цифр, после запятой
// Float - точность 6 чисел после запятой

// MARK: Строгая типизация и вывод типов

// Литеральное значение - это значение, которое появляется непосредственно в исходном коде (например как 42)

let meaningOfLide = 42

let pi = 3 + 0.14159
// литеральное значение 3 не имеет явного типа само по себе


// MARK: Числовые литералы

// Числовые литералы могут быть написаны как:
/*
 - десятичное число без префикса
 - двоичное число, с префиксом 0b
 - восьмеричное число, с префиксом 0o
 - шестнадцатеричное число, с префиксом 0x
 */

// все эти литералы целого числа имеют значение 17
let decimalInteger = 17
let binaryInteger = 0b10001
let octalInteger = 0o21
let hexadecimalInteger = 0x11

// литералы с плавающей точкой могут быть десятичными (без префикса) или шестнадцатиричными (с префиксом 0x). Они всегда должны иметть число по обе стороны от дробной точки. Они также могут иметь экспоненту, с указанием в верхнем или нижнем регистре е для десятичных чисел с плавающей точкой, или в верхнем или нижнем регистре p для шестнадцатеричных чиел с плавающей точкой

// для десятичных чисел с показателем степени exp, базовое число умножается на 10exp:
1.25e4 // 125.0 (e2 = 100, e3 = 1000, e4 = 10000 и т.д.)
1.25e-1 // 0.0125 (-e2 = 0.01, -e1 = 0,1, e1 = 10)

// для шестнадцатеричных чисел показатель степни exp, базоваое число умножается на 2exp:
0xFp2 // означает 15 х 2 во второй или 60.0
0xFp-2 // означает 15 х 2 в -2 или 3.75

// Все эти числа с плавающей запятой имеют десятичное значение 12.125:
let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0x1.3p0//p0

// числовые литералы могут содержать дополнительное форматирование, чтобы их было удобнее читать. целые числа и числа с плавающей точкой могут быть дополнены нулями и могут содержать символы подчеркивания для увеличения читабельности. Ни один тип форматирования не влияет на базовое значение дитерала:
let paddedDounle = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1

// MARK: Преобразования целых чисел

// ошибка переполнения (overflow)
// let connotBeNegative: UInt8 = -1
// var tooBig: Int8 = Int8.max + 1

// Так как каждый числовой тип может хранить разный диапазон значений, в зависимости от конкретного случае вам придется обращаться к преобразованию числовых типов. Этот подход предотвращает скрытые ошибки преобразования и помогает сделать причину преобразования понятной

// Пример преобразования числовых типов
let twoThosand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = UInt16(one) + twoThosand

// NameType(initialValue) - стандартный способ вызвать инициализатор типов Swift и передать начальное значение.

// MARK: Преобразование целых чисел и чисел с плавающей точкой

let three = 3
let pointOneFourOneFiveNine = 0.14159
let piNumber = Double(three) + pointOneFourOneFiveNine

// Обратное преобразование
let integerPi = Int(piNumber)
// Числа с плавающей точкой всегда урезаются когда используется инициализация числа через этот способ

// Правила объединения числовых констант и переменных отличаются от правил числовых литералов. Литеральное значение 3 может напрямую сложиться со значением 0.14159, потому что числовые литералы сами по себе не имеют явного типа. Их тип выводиться только в момент оценки значения компилятором

// MARK: Псевдонимы типов (typealias)
// Псевдонимы типов задают альтернативное имя для существующего типа. Можно задать псевдоним типа с помощью ключевого слова typealias

// Псевдонимы типов полезны, когда вы хотите обраиться к существующему типу по имени, которое больше подходит по контексту, например когда вы работаете с данными определенного размера из внешнего источника:

typealias AudioSamle = UInt16
var maxAmplitudeFound = AudioSamle.min

// MARK: Tuples
// Кортежи групируют несколько значений в одно составное значение. Значения внутри кортежа могут быть любого типа.

let http404Error = (404, "Not Found")
type(of: http404Error)

// Можно разложить кортеж на отдельные константы и переменные
let (statusCode, statusMessage) = http404Error
print("the status code is \(statusCode)")
print("the status message is " + statusMessage)

// если нужны только некоторые из значений кортежа, можно игнорировать части кортежа с помощью символа (_):
let (justTheStatusCode, _) = http404Error
print("the status code is \(justTheStatusCode)")

// в качестве альтернативы можно получать доступ к отдельным элементам кортежа, используя числовые индексы, начинающиеся с нуля:
print("the status code is \(http404Error.0)")

// можно давать имена отдельным элементам кортежа во время объявления:
let http200Status = (statusCode: 200, description: "OK")

http200Status.description
http200Status.statusCode

// Кортежи особенно полезны в качестве возвращаемых значений функций.
// Кортежи полезны для временной группировки связанных значений. Они не подходят для создания сложных структур данных.

// MARK: Опциональные типы (опционалы)
// Опциональные типы используются в тех случаях, когда значение может отсутствовать. Опциональный тип подразумевает, что возможны два варианта - или значение есть и его можно извлечь из опционала, либо его вообще нет (nil)
// Опционалы Swift позволяют указать отсутствие значения для абсолютно любого типа, без необходимости использования специальных констант

let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
type(of: convertedNumber)
// поскольку метод Int() может иметь недопустимый аргумент, он возвращает опциональный Int?, вместо Int. Опциональный Int записывается как Int?. Знак вопроса означает, что содержащееся в ней значение является опциональным, что означает что он может содержать некоторое Int значение, или он может не содержать вообще никакого значения.

// nil
// мы можем установить опциональную переменную в состояние отсутствия значения, путем присвоения ему специального значения nil
var serverResponceCode: Int? = 404
serverResponceCode = nil

// nil не может быть использован с неопциональными константами и переменными

// если не инициализировать переменную опционального типа при объявлении, то она автоматически установиться в nil
var survey: Int?

// В Swift nil является отсутствием значения определенного типа. Устанавливаться в nil могут опционалы любого типа, а не только типы объектов

// MARK:  Инструкция if и принудитеьное извлечение

// Можно сравнивать опционал с nil, используя инструкцию if, с помощью операторов равенства (==) или неравенства (!=)

if convertedNumber != nil {
    print("covertedNumber contains some integer value")
}



// Если вы уверены, что опционал содержит значение, вы можете получить доступ к его значению, добавив восклицательный знак (!) в конце имени опционала. Восклицательный знак фактически говорит: "Я знаю точно, что этот опционал содержит значение, пожалуйста используй его". Это выражение известно как "Принудительное извлечение опционала" Forced unwraping

if convertedNumber != nil {
    print("convertedNumber has an integer value of \(convertedNumber!)")
}

// ! По сути, это более короткое написание fatalError(_:file:line:). Например, приведенный ниже код показывает два эквивалентных подхода:
convertedNumber!
// эквивалентное этому выражение
guard let number = convertedNumber else {
    fatalError("The number was invalid")
}

// Попытка использовать ! к несуществующему значению вызовет runtime ошибку.

// MARK: Привязка опционалов (Optional binding)
// Можно использовать Привязку опционалов, чтобы выяснить содержит ли опционал значение, и если да, то сделать это значение доступным в качестве временной константы или переменной. Привязка опционалов может испоьзоваться с инстукциями if, guard и while, для проверки значения внутри опционала, и извлечения этого значения в константу или переменную, в рамках одного действия.

// syntax with if
/*
 if let constantName = someOptional {
    statements
 }
 */

// можно использвать и константы и переменные для привязки опционалов

if var optionalNumber = Int(possibleNumber) {
    optionalNumber = 12
    print("\(possibleNumber) has an integer value of \(optionalNumber)")
} else {
    print("\(possibleNumber) could not be convaerted to an integer")
}

// возможно использование сокращенного синтаксиса для привязки опционала. Новая развернутая временная константа или переменная использует то же имя
let myNumber = Int(possibleNumber)

if let myNumber {
    print("my number is \(myNumber)")
}

// Можно включать призвольное количество опциональных привязок и логических условий в единую конструкцию if, разделяя их запятыми. Если какое то значение в опциональной привязке равно nil, или любое логическое условие вычисляется как false, то все выражеение будет false

// два эквивалентных выражения
if let firstNumber = Int("3"), let secondNumber = Int("43"), firstNumber < secondNumber && secondNumber < 100 {
    print("\(firstNumber) < \(secondNumber) < 100")
}

if let firstNumber = Int("3") {
    if let secondNumber = Int("43") {
        if firstNumber < secondNumber && secondNumber < 100 {
            print("\(firstNumber) < \(secondNumber) < 100")
        }
    }
}

// Константы и переменные, созданные через опциональную привязку в инструкции if, будут доступны только в теле инструкции if. В противоположность этому, константы и переменные, созданные через инструкцию guard, доступны в строках кода, следующих за инструкцией guard

// MARK: Providing a Fallback value (предоставление резервного значения)
// Оператор ?? используется для определения значения в опционале, если значение есть то выплняется левая часть и оно извлекается из опционал, если значение отсутствует выполняется правая часть и возвращается резервное значение

let name: String? = nil
let greeting = "Hello, " + (name ?? "friend") + "!"
print(greeting)


// MARK: Неявно извлеченные опционалы
// Неявно извлеченны опционалы полезны, когда известно что значение опционала существует непосредственно после первого объявления опционала, и точно будет существовать после этого. В основном используются во время инициализации класса
// Могут быть использованы как не опциональные значения, без необходимости в извлечении опционального значения каждый раз при доступе.

let possibleString: String? = "An optional string"
let forcedString = possibleString! // необходим восклицательный знак

let assumedStrig: String! = "An implicitly unwrapped optional strng"
let implicitString: String = assumedStrig // восклицательный знак не нужен

// Попытка использовать ! к несуществующему значению вызовет runtime ошибку.

if assumedStrig != nil {
    print(assumedStrig!)
}

if let definiteString = assumedStrig {
    print(definiteString)
}

//  Нельзя использовать неявно извлеченный опционал, если существует вероятность, что в будущем переменная может стать nil. Всегда используйте нормальный тип опционала, если нужно проверять на nil значение в течение срока службы переменной

let optionalString = assumedStrig
print(type(of: optionalString))

// можно проверить неявно извлеченный опционал таким же способом, как и проверка обычного опционала
if let definiteString = assumedStrig {
    print(definiteString)
}

// MARK: Обработка ошибок
// Обработка ошибок позволяет определить причину сбоя, и при необходимости, передать ошибку в другую часть вашей программы
// Когда функция обнаруживает условие ошибки, она выдает сообщение об ошибке. Тот, кто вызывает функцию, может затем поймать ошибку и среагировать соответствующим образом
func canThrowAnError() throws {
    // эта функция может генерировать ошибку
}
// Функция сообщает о возможности генерации ошибки, включив ключевое слово trows в объявление. Когда вы вызываете функцию, которая может выбросить ошибку, вы добавляете ключевое слово try в выражение. Swift автоматически передает ошибки из текущей области, пока они не будут обработаны условием catch.
do {
    try canThrowAnError()
    // ошибка не была сгенерирована
} catch {
    // ошибка сгенерирована
}
// выражение do создает область, содержащую объект, которая позволяет ошибкам быть переданными в одно или несколько условий catch

// пример того, как обработка ошибок может быть использована в ответ на различные условия возникновения ошибок:
enum SandwichError: Error {
    case outOfCleanDishes
    case missingIngridients(ingridients: String)
}

class Sandwich {
    func makeASandwich() throws {
        //..
        print("Sandwich ready")
    }
    func eatASandwich() {
        //..
        print("Mmmm yam yam")
    }
    func washDishes() {
        //..
        print("Wash dishes")
    }
    func buyGloceries(ingridients: String) -> String {
        print("need \(ingridients)")
        return ingridients
    }
}

let someSandwich = Sandwich()


do {
    try someSandwich.makeASandwich()
    someSandwich.eatASandwich()
} catch SandwichError.outOfCleanDishes {
    someSandwich.washDishes()
} catch SandwichError.missingIngridients(let ingridients) {
    someSandwich.buyGloceries(ingridients: ingridients)
}

// MARK: Утверждения и предусловия
// Утверждения и предусловия являются проверками во время исполнения. Вы используете их для того, чтобы убедиться, что какое либо уловие уже выполнено, прежде чем начнется исполнение последующего кода. Если булево значение в утверждении или предусловии равно true, то выполнение кода просто продолжается далее, но если значение равно false, то текущее состояние исполнения программы некорректно и выполнение кода останавливается и ваше приложение завершает работу.

var age = -3
age = 1
//assert(age >= 0, "age cannot be less than zero")

if age > 10 {
    print("You can ride the roller-coaster or the ferris wheel.")
} else if age >= 0 {
    print("You can ride the ferris wheel.")
} else {
    assertionFailure("A person's age can't be less than zero.")
}

// MARK: Обеспечение предусловиями
// Может использлваться для проверки того, что значение сабскрипта не вышло за границы диапазона или для проверки того, что в функцию передано корректное значение
// Для использования предусловий вызовите функцию precondition(_:_:file:line:). Вы передаете этой функции выражение, которое вычисляется как true или false и сообщение, которое отобразиться если условие будет false

// в реализации сабскрипта
// precondition(index > 0, "Index cannot be greater than zero")

// Так же возможно вызвать функцию preconditionFailure(_:_:file:line:) для индикации, что отказ работы уже произошел, например, если сработал дефолтный кейс инструкции switch

// Если компилируем в режиме -Ounchecked, то предусловия не проверяются. Компилятор предпологает, что предусловия всегда получают значения true, и он оптимизирует ваш код соответствующим образом. Однако, функция fatalError(_:file:line:) всегда останавливает исполнение, несмотря на настройки оптимизации.

// Можно использовать функцию fatalError(_:file:line:) во время прототипирования или ранней разработки для создания заглушек для функциональности, которая еще не реализована, написав fatalError("Unimplemented") в качестве реализации заглушки. Поскольку фатальные ошибки никогда не оптимизируются, в отличии от утверждений или предусловий, можно быть увереннным что выполнение кода всегда прекратится, если оно встречает реализацию заглушки
