//: [Previous](@previous)

import Foundation

// MARK: Classes and Structures

// В отличии от других языков программирования, Swift не требует создавать отдельные файлы для интерфейсов и реализации пользовательских классво и структур. В Swift, вы объявляете структуру или класс в одном файле, и внешний интерфейс автоматически становится доступным для использования в другом коде.
// Экземпляр класса традиционно называют объектом. Но так как в Swift структуры и классы гораздо ближе по своей функциональности, чем в других языках. Для классов и структур, употребляется более общий термин - экземпляр (instance)

// MARK: Сравнение классов и структур
/*
И классы и структуры могут:
 1. Объявлять свойства для хранения значений
 2. Объявлять методы, чтобы обеспечить функциональность
 3. Объявлять индексы, чтобы обеспечить доступ к их значениям, через синтаксис индексов
 4. Объявлять инициализаторы, чтобы установить их первоначальное состояние
 5. Они оба могут быть расширены, чтобы расширить их функциональность за пределами стандартной реализации
 6. Они оба могут соответствовать протоколам, для обеспечения стандартной функциональности определенного типа
 */

/*
 Классы имеют дополнительные возможности, которых нет у структур:
 1. Наследование позволяет одному классу наследовать характеристики другого
 2. Приведение типов позволяет проверить и интерпретировать тип экземпялра класса в процессе выполнения
 3. Деинициализаторы позволяют экземпяру класса освободить любые ресурсы, которые он использовал
 4. Подсчет ссылок допускает более чем одну ссылку на экземпляр класса
 */
// Дополнительные возможности поддержки классов связаны с увеличением сложности. Лучше использовать стуктуры и перечисления, потому что их легче понимать.

// MARK: Синтаксис объявления

// Создавая новый класс или структуру, фатически создается новый тип в Swift. Имена типов должны быть в стиле UpperCamelCase, имена свойств и методов - lowerCamelCase

struct Resolution {
    var width = 0
    var height = 0
}
class VideoMode {
    var resolution = Resolution()
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}

// MARK: Экземляры класса и структуры
// Создание экземпляра структуры и класса с помощью синтаксиса инициализатора c значениями по умолчанию

let someResolution = Resolution()
let someVideoMode = VideoMode()

// MARK: Доступ к свойствам
// Доступ к свойствам через точечный синтаксис:

print("The width of someResolution is \(someResolution.width)")

print("The width of someVideoMode is \(someVideoMode.resolution.width)")

// Использование точечного синтаксиса для присваивания нового значения свойства экземпляра:
someVideoMode.resolution.width = 1280

// MARK: Поэлементные инициализаторы структурных типов

// Все структуры имеют автоматически генерированный "поэлементный инициализатор":

let vga = Resolution(width: 640, height: 480)

// В отличии от структур классы не получили поэлементного инициализатора исходных значений

// MARK: Структуры и перечисления - Value types

// Value type - это тип, значение которого копируется, когда оно присваивается константе или переменной, ил когда передается функции

// Все базовые типы Swift (Int, Bool, Double и т.д.) это Value types, которые реализованы как стуктуры

// Все структуры и перечисления - Value types в Swift. Это значит, что любой экземпляр структуры и перечисления, который вы создаете, и любые типы значений, которые они имеют в качестве свойств, всегда копируются, когда он передается по вашему коду

// Коллекции, определенные стандартной библиотекой Swift, такие как массивы, словари и строки, используют оптимизацию для снижения затрат на копирование. Вместо того чтобы немедленно сделать копию, эти коллекции совместно используют память, в которой элементы хранятся между исходным экземпяром и любыми копиями. Если одна из коллекций модифицирована, элементы копируются непосредственно перед изменением.

let hd = Resolution(width: 1920, height: 1080)
var cinema = hd

cinema.width = 2048
print("cinema is now \(cinema.width) pixels wide")

print("hd is still \(hd.width) pixels wide")

// Тоже поведение характерно и для перечислений

enum CompassPoint {
    case north, south, east, west
    mutating func turnNorth() {
        self = .north
    }
}
var currentDirection = CompassPoint.west
let rememberedDirection = currentDirection
currentDirection.turnNorth()

print("Текущее направление - \(currentDirection)")
print("remembered direction - \(rememberedDirection)")

// MARK: Классы - reference type

// В отличии от value type, reference type не покируется, когда его присваивают переменной или константе, или когда его передают функции. Вместо копирования используется ссылка на существующий экземпляр

let tenEighty = VideoMode()
tenEighty.resolution = hd
tenEighty.interlaced = true
tenEighty.name = "1080i"
tenEighty.frameRate = 25.0

let alsoTenEighty = tenEighty
alsoTenEighty.frameRate = 30.0

// Так как это ссылочный тип, то экземпляры tenEighty и alsoTenEighty ссылаются на один и тот же экземпляр VideoMode. Фактически получается, что у нас два разных имени для одного единственного экземпяра

print("The frameRate property of tenEighty is now \(tenEighty.frameRate)")

// tenEighty и alsoTenEighty объявлены как константы, а не переменные. Однако вы все равно можно изменять tenEighty.frameRate и alsoTenEighty.frameRate так как значения tenEighty и alsoTenEighty сами по себе не меняются, так как они не "содержат" значение экземпляра VideoMode, а напротив они лишь ссылаются на него. Это свойство frameRate, лежащего в основе VideoMode, которое меняется, а не значения константы ссылающейся на VideoMode

// MARK: Операторы тождественности

// Так как классы являются ссылочными типами, то есть возможность сделать так, чтобы несколько констант и переменных ссылались на один единственный экземпляр класса.

// Оператор тождественности - определяет ссылаются ли две константы или переменные на один и тот же экземпляр класса.
// Идентичен (===)
// Не идентичен (!==)

if tenEighty === alsoTenEighty {
    print("tenEighty and alsoTenEighte refer to the same VideoMode instance")
}





//: [Next](@next)
